<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="../../../laika/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../../../laika/parse/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.code" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="code"></a><a id="code:code"></a>
      <span class="permalink">
      <a href="../../../laika/parse/code/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../code/index.html"><span class="name">code</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.combinator" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combinator"></a><a id="combinator:combinator"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../combinator/index.html"><span class="name">combinator</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.css" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="css"></a><a id="css:css"></a>
      <span class="permalink">
      <a href="../../../laika/parse/css/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../css/index.html"><span class="name">css</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.directive" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="directive"></a><a id="directive:directive"></a>
      <span class="permalink">
      <a href="../../../laika/parse/directive/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../directive/index.html"><span class="name">directive</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.hocon" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hocon"></a><a id="hocon:hocon"></a>
      <span class="permalink">
      <a href="../../../laika/parse/hocon/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../hocon/index.html"><span class="name">hocon</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.markup" visbl="pub" class="indented3 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markup"></a><a id="markup:markup"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">markup</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <a class="object" href="BlockParsers$.html" title="Instance that allows to import all block parsers in isolation."></a>
                        <a class="trait" href="BlockParsers.html" title="Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages."></a>
                        <a href="BlockParsers.html" title="Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages.">BlockParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="DefaultEscapedTextParsers.html" title="Default implementation for parsing escape sequences."></a>
                        <a href="DefaultEscapedTextParsers.html" title="Default implementation for parsing escape sequences.">DefaultEscapedTextParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="DefaultRecursiveParsers.html" title="Default implementation for parsing inline markup and blocks recursively."></a>
                        <a href="DefaultRecursiveParsers.html" title="Default implementation for parsing inline markup and blocks recursively.">DefaultRecursiveParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="DefaultRecursiveSpanParsers.html" title="Default implementation for parsing inline markup recursively."></a>
                        <a href="DefaultRecursiveSpanParsers.html" title="Default implementation for parsing inline markup recursively.">DefaultRecursiveSpanParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="DocumentParser$.html" title="Responsible for creating the top level parsers for text markup and template documents, by combining the parser for the root element with a parser for an (optional) configuration header."></a>
                        <a href="DocumentParser$.html" title="Responsible for creating the top level parsers for text markup and template documents, by combining the parser for the root element with a parser for an (optional) configuration header.">DocumentParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="EndDelimiter.html" title="The result in case the end delimiter for the text has been parsed."></a>
                        <a href="EndDelimiter.html" title="The result in case the end delimiter for the text has been parsed.">EndDelimiter</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="EscapedTextParsers.html" title="Provides parsers for escaped text, custom span parser implementations can use these without knowing the rules of the host markup language for escaping text."></a>
                        <a href="EscapedTextParsers.html" title="Provides parsers for escaped text, custom span parser implementations can use these without knowing the rules of the host markup language for escaping text.">EscapedTextParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="InlineDelimiter.html" title="Delimiter implementation for parsing inline spans that distinguishes between a delimiter that marks the end of the span and a delimiter that marks the start of a nested span."></a>
                        <a href="InlineDelimiter.html" title="Delimiter implementation for parsing inline spans that distinguishes between a delimiter that marks the end of the span and a delimiter that marks the start of a nested span.">InlineDelimiter</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="InlineParser.html" title="Generic base parser that parses inline elements with potentially nested spans."></a>
                        <a href="InlineParser.html" title="Generic base parser that parses inline elements with potentially nested spans.">InlineParser</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="InlineParsers$.html" title="Instance that allows to import all inline parsers in isolation."></a>
                        <a class="trait" href="InlineParsers.html" title="Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages."></a>
                        <a href="InlineParsers.html" title="Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages.">InlineParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="InlineResult.html" title="The result of text parsed with an InlineDelimiter."></a>
                        <a href="InlineResult.html" title="The result of text parsed with an InlineDelimiter.">InlineResult</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="NestedDelimiter.html" title="The result in case the start character of a nested span has been parsed."></a>
                        <a href="NestedDelimiter.html" title="The result in case the start character of a nested span has been parsed.">NestedDelimiter</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveBlockParser.html" title="Parses a sequence of blocks based on the available block types of the host markup language."></a>
                        <a href="RecursiveBlockParser.html" title="Parses a sequence of blocks based on the available block types of the host markup language.">RecursiveBlockParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveParsers.html" title="Provides parsers for nested blocks, custom block parser implementations can use these without knowing the available span or block types of the host markup language."></a>
                        <a href="RecursiveParsers.html" title="Provides parsers for nested blocks, custom block parser implementations can use these without knowing the available span or block types of the host markup language.">RecursiveParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveSpanParser.html" title="Parses a sequence of spans based on the available spans types of the host markup language."></a>
                        <a href="RecursiveSpanParser.html" title="Parses a sequence of spans based on the available spans types of the host markup language.">RecursiveSpanParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="trait" href="RecursiveSpanParsers.html" title="Provides parsers for nested spans, custom span parser implementations can use these without knowing the available span types of the host markup language."></a>
                        <a href="RecursiveSpanParsers.html" title="Provides parsers for nested spans, custom span parser implementations can use these without knowing the available span types of the host markup language.">RecursiveSpanParsers</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="RootParser.html" title="Responsible of assembling all the block, inline, text and configuration parsers supported by a text markup language."></a>
                        <a href="RootParser.html" title="Responsible of assembling all the block, inline, text and configuration parsers supported by a text markup language.">RootParser</a>
                      </li><li name="laika.parse.text" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text"></a><a id="text:text"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../text/index.html"><span class="name">text</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.uri" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uri"></a><a id="uri:uri"></a>
      <span class="permalink">
      <a href="../../../laika/parse/uri/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../uri/index.html"><span class="name">uri</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../index.html" class="extype" name="laika">laika</a>.<a href="../index.html" class="extype" name="laika.parse">parse</a></p>
        <h1>markup<span class="permalink">
      <a href="../../../laika/parse/markup/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">markup</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              
            </ol>
          </div>
          
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.parse.markup.BlockParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="BlockParsersextendsAnyRef"></a><a id="BlockParsers:BlockParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/BlockParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages." href="BlockParsers.html"><span class="name">BlockParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages.</p><div class="fullcomment"><div class="comment cmt"><p>Provides base parsers that abstract aspects of block parsing common to most lightweight markup languages.</p><p> A block parser in Laika can always safely assume that it is invoked at
 the start of the current line and that the line is not empty.
</p></div></div>
    </li><li name="laika.parse.markup.DefaultEscapedTextParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="DefaultEscapedTextParsersextendsEscapedTextParsers"></a><a id="DefaultEscapedTextParsers:DefaultEscapedTextParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/DefaultEscapedTextParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Default implementation for parsing escape sequences." href="DefaultEscapedTextParsers.html"><span class="name">DefaultEscapedTextParsers</span></a><span class="result"> extends <a href="EscapedTextParsers.html" class="extype" name="laika.parse.markup.EscapedTextParsers">EscapedTextParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Default implementation for parsing escape sequences.</p>
    </li><li name="laika.parse.markup.DefaultRecursiveParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="DefaultRecursiveParsersextendsRecursiveParserswithDefaultRecursiveSpanParsers"></a><a id="DefaultRecursiveParsers:DefaultRecursiveParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/DefaultRecursiveParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Default implementation for parsing inline markup and blocks recursively." href="DefaultRecursiveParsers.html"><span class="name">DefaultRecursiveParsers</span></a><span class="result"> extends <a href="RecursiveParsers.html" class="extype" name="laika.parse.markup.RecursiveParsers">RecursiveParsers</a> with <a href="DefaultRecursiveSpanParsers.html" class="extype" name="laika.parse.markup.DefaultRecursiveSpanParsers">DefaultRecursiveSpanParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Default implementation for parsing inline markup and blocks recursively.</p>
    </li><li name="laika.parse.markup.DefaultRecursiveSpanParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="DefaultRecursiveSpanParsersextendsRecursiveSpanParserswithDefaultEscapedTextParsers"></a><a id="DefaultRecursiveSpanParsers:DefaultRecursiveSpanParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/DefaultRecursiveSpanParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Default implementation for parsing inline markup recursively." href="DefaultRecursiveSpanParsers.html"><span class="name">DefaultRecursiveSpanParsers</span></a><span class="result"> extends <a href="RecursiveSpanParsers.html" class="extype" name="laika.parse.markup.RecursiveSpanParsers">RecursiveSpanParsers</a> with <a href="DefaultEscapedTextParsers.html" class="extype" name="laika.parse.markup.DefaultEscapedTextParsers">DefaultEscapedTextParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Default implementation for parsing inline markup recursively.</p>
    </li><li name="laika.parse.markup.EndDelimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="EndDelimiterextendsInlineResultwithProductwithSerializable"></a><a id="EndDelimiter:EndDelimiter"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/EndDelimiter.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="The result in case the end delimiter for the text has been parsed." href="EndDelimiter.html"><span class="name">EndDelimiter</span></a><span class="params">(<span name="capturedText">capturedText: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <a href="InlineResult.html" class="extype" name="laika.parse.markup.InlineResult">InlineResult</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">The result in case the end delimiter for the text has been parsed.</p>
    </li><li name="laika.parse.markup.EscapedTextParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="EscapedTextParsersextendsAnyRef"></a><a id="EscapedTextParsers:EscapedTextParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/EscapedTextParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides parsers for escaped text, custom span parser implementations can use these without knowing the rules of the host markup language for escaping text." href="EscapedTextParsers.html"><span class="name">EscapedTextParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides parsers for escaped text, custom span parser implementations
can use these without knowing the rules of the host markup language for
escaping text.</p>
    </li><li name="laika.parse.markup.InlineDelimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="InlineDelimiterextendsDelimiter[laika.parse.markup.InlineResult]"></a><a id="InlineDelimiter:InlineDelimiter"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineDelimiter.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Delimiter implementation for parsing inline spans that distinguishes between a delimiter that marks the end of the span and a delimiter that marks the start of a nested span." href="InlineDelimiter.html"><span class="name">InlineDelimiter</span></a><span class="result"> extends <span class="extype" name="laika.parse.text.Delimiter">Delimiter</span>[<a href="InlineResult.html" class="extype" name="laika.parse.markup.InlineResult">InlineResult</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Delimiter implementation for parsing inline spans that distinguishes
between a delimiter that marks the end of the span and a delimiter
that marks the start of a nested span.</p>
    </li><li name="laika.parse.markup.InlineParser" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InlineParser[Elem,To]extendsParser[To]"></a><a id="InlineParser[Elem,To]:InlineParser[Elem,To]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParser.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Generic base parser that parses inline elements with potentially nested spans." href="InlineParser.html"><span class="name">InlineParser</span></a><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="result"> extends <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.markup.InlineParser.To">To</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Generic base parser that parses inline elements with potentially nested spans.</p><div class="fullcomment"><div class="comment cmt"><p>Generic base parser that parses inline elements with potentially nested spans.</p><p>The two embed methods allow the registration of parsers for nested child spans.
They can be invoked multiple times. Child parsers passed first have higher
precedence than those passed later.</p><p>Only parsers of type <code>PrefixedParser[T]</code> can be passed to the embed methods,
which are parsers with known, stable prefixes of the child span consisting
of a limited set of characters so that the checks that need to be performed
for each character can be optimized for performance.
</p></div><dl class="paramcmts block"><dt class="tparam">Elem</dt><dd class="cmt"><p>the element type produced by a single parser for a nested span</p></dd><dt class="tparam">To</dt><dd class="cmt"><p>the type of the result this parser produces</p></dd></dl></div>
    </li><li name="laika.parse.markup.InlineParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="InlineParsersextendsAnyRef"></a><a id="InlineParsers:InlineParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages." href="InlineParsers.html"><span class="name">InlineParsers</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages.</p><div class="fullcomment"><div class="comment cmt"><p>Provides base parsers that abstract aspects of inline parsing common to most lightweight markup languages.</p><p> It contains helper parsers that abstract the typical logic required for parsing
 nested spans. In many cases a parser has to recognize the end of the span as well
 as potentially the start of a nested span. These two concerns are usually unrelated.</p><p> This object offers helpers that simplify creating these types of parsers and also
 optimize performance of inline parsing. Due to the nature of lightweight text markup
 inline parsing would usually require trying a long list of choices on each input
 character, which is slow. These base parsers work based on mappings from the first
 character of an inline span to the corresponding full parser.
</p></div></div>
    </li><li name="laika.parse.markup.InlineResult" visbl="pub" class="indented0 " data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="InlineResultextendsAnyRef"></a><a id="InlineResult:InlineResult"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineResult.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">sealed </span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="The result of text parsed with an InlineDelimiter." href="InlineResult.html"><span class="name">InlineResult</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">The result of text parsed with an <code>InlineDelimiter</code>.</p>
    </li><li name="laika.parse.markup.NestedDelimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="NestedDelimiterextendsInlineResultwithProductwithSerializable"></a><a id="NestedDelimiter:NestedDelimiter"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/NestedDelimiter.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="The result in case the start character of a nested span has been parsed." href="NestedDelimiter.html"><span class="name">NestedDelimiter</span></a><span class="params">(<span name="startChar">startChar: <span class="extype" name="scala.Char">Char</span></span>, <span name="capturedText">capturedText: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <a href="InlineResult.html" class="extype" name="laika.parse.markup.InlineResult">InlineResult</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <p class="shortcomment cmt">The result in case the start character of a nested span has been parsed.</p>
    </li><li name="laika.parse.markup.RecursiveBlockParser" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RecursiveBlockParserextendsAnyRef"></a><a id="RecursiveBlockParser:RecursiveBlockParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/RecursiveBlockParser.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Parses a sequence of blocks based on the available block types of the host markup language." href="RecursiveBlockParser.html"><span class="name">RecursiveBlockParser</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Parses a sequence of blocks based on the available block types of the host markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a sequence of blocks based on the available block types of the host markup language.</p><p>This parser always parses to the end of the input, therefore it is usually applied to
the result of a previous parser invocation.</p><p>The API is restricted and not the standard <code>Parser</code> API to prevent invocations with
just a plain string which would lose all position tracking in error messages.
Instead both methods expect a full <code>SourceFragment</code> instance which carries the context
of the root input.
</p></div></div>
    </li><li name="laika.parse.markup.RecursiveParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RecursiveParsersextendsRecursiveSpanParsers"></a><a id="RecursiveParsers:RecursiveParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/RecursiveParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides parsers for nested blocks, custom block parser implementations can use these without knowing the available span or block types of the host markup language." href="RecursiveParsers.html"><span class="name">RecursiveParsers</span></a><span class="result"> extends <a href="RecursiveSpanParsers.html" class="extype" name="laika.parse.markup.RecursiveSpanParsers">RecursiveSpanParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Provides parsers for nested blocks, custom block parser implementations can use these without knowing
the available span or block types of the host markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Provides parsers for nested blocks, custom block parser implementations can use these without knowing
the available span or block types of the host markup language.</p><p>Includes the support for nested spans and escaped text.
</p></div></div>
    </li><li name="laika.parse.markup.RecursiveSpanParser" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RecursiveSpanParserextendsAnyRef"></a><a id="RecursiveSpanParser:RecursiveSpanParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/RecursiveSpanParser.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Parses a sequence of spans based on the available spans types of the host markup language." href="RecursiveSpanParser.html"><span class="name">RecursiveSpanParser</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Parses a sequence of spans based on the available spans types of the host markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a sequence of spans based on the available spans types of the host markup language.</p><p>This parser always parses to the end of the input, therefore it is usually applied to
the result of a previous parser invocation.</p><p>The API is restricted and not the standard <code>Parser</code> API to prevent invocations with
just a plain string which would lose all position tracking in error messages.
Instead both methods expect a full <code>SourceFragment</code> instance which carries the context
of the root input.
</p></div></div>
    </li><li name="laika.parse.markup.RecursiveSpanParsers" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="RecursiveSpanParsersextendsEscapedTextParsers"></a><a id="RecursiveSpanParsers:RecursiveSpanParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/RecursiveSpanParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a title="Provides parsers for nested spans, custom span parser implementations can use these without knowing the available span types of the host markup language." href="RecursiveSpanParsers.html"><span class="name">RecursiveSpanParsers</span></a><span class="result"> extends <a href="EscapedTextParsers.html" class="extype" name="laika.parse.markup.EscapedTextParsers">EscapedTextParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Provides parsers for nested spans, custom span parser implementations
can use these without knowing the available span types of the host
markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Provides parsers for nested spans, custom span parser implementations
can use these without knowing the available span types of the host
markup language.</p><p>Includes the support for escaped text.
</p></div></div>
    </li><li name="laika.parse.markup.RootParser" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="RootParserextendsDefaultRecursiveParsers"></a><a id="RootParser:RootParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/RootParser.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Responsible of assembling all the block, inline, text and configuration parsers supported by a text markup language." href="RootParser.html"><span class="name">RootParser</span></a><span class="result"> extends <a href="DefaultRecursiveParsers.html" class="extype" name="laika.parse.markup.DefaultRecursiveParsers">DefaultRecursiveParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Responsible of assembling all the block, inline, text and configuration parsers
supported by a text markup language.</p>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="laika.parse.markup.BlockParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BlockParsers"></a><a id="BlockParsers:BlockParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/BlockParsers$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Instance that allows to import all block parsers in isolation." href="BlockParsers$.html"><span class="name">BlockParsers</span></a><span class="result"> extends <a href="BlockParsers.html" class="extype" name="laika.parse.markup.BlockParsers">BlockParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Instance that allows to import all block parsers in isolation.</p><div class="fullcomment"><div class="comment cmt"><p>Instance that allows to import all block parsers in isolation.</p><p>Usually it is more convenient to import laika.parse.api._
to get all parser builders with one import.
</p></div></div>
    </li><li name="laika.parse.markup.DocumentParser" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="DocumentParser"></a><a id="DocumentParser:DocumentParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/DocumentParser$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Responsible for creating the top level parsers for text markup and template documents, by combining the parser for the root element with a parser for an (optional) configuration header." href="DocumentParser$.html"><span class="name">DocumentParser</span></a>
      </span>
      
      <p class="shortcomment cmt">Responsible for creating the top level parsers for text markup and template documents,
by combining the parser for the root element with a parser for an (optional) configuration
header.</p>
    </li><li name="laika.parse.markup.InlineParsers" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="InlineParsers"></a><a id="InlineParsers:InlineParsers"></a>
      <span class="permalink">
      <a href="../../../laika/parse/markup/InlineParsers$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Instance that allows to import all inline parsers in isolation." href="InlineParsers$.html"><span class="name">InlineParsers</span></a><span class="result"> extends <a href="InlineParsers.html" class="extype" name="laika.parse.markup.InlineParsers">InlineParsers</a></span>
      </span>
      
      <p class="shortcomment cmt">Instance that allows to import all inline parsers in isolation.</p><div class="fullcomment"><div class="comment cmt"><p>Instance that allows to import all inline parsers in isolation.</p><p>Usually it is more convenient to import laika.parse.api._
to get all parser builders with one import.
</p></div></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
