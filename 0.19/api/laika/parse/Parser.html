<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../lib/index.js"></script>
      <script type="text/javascript" src="../../index.js"></script>
      <script type="text/javascript" src="../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="../../laika/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../../laika/parse/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.code" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="code"></a><a id="code:code"></a>
      <span class="permalink">
      <a href="../../laika/parse/code/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="code/index.html"><span class="name">code</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.combinator" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="combinator"></a><a id="combinator:combinator"></a>
      <span class="permalink">
      <a href="../../laika/parse/combinator/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="combinator/index.html"><span class="name">combinator</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.css" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="css"></a><a id="css:css"></a>
      <span class="permalink">
      <a href="../../laika/parse/css/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="css/index.html"><span class="name">css</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.directive" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="directive"></a><a id="directive:directive"></a>
      <span class="permalink">
      <a href="../../laika/parse/directive/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="directive/index.html"><span class="name">directive</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.hocon" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hocon"></a><a id="hocon:hocon"></a>
      <span class="permalink">
      <a href="../../laika/parse/hocon/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="hocon/index.html"><span class="name">hocon</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.markup" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markup"></a><a id="markup:markup"></a>
      <span class="permalink">
      <a href="../../laika/parse/markup/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="markup/index.html"><span class="name">markup</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.text" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text"></a><a id="text:text"></a>
      <span class="permalink">
      <a href="../../laika/parse/text/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="text/index.html"><span class="name">text</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li name="laika.parse.uri" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uri"></a><a id="uri:uri"></a>
      <span class="permalink">
      <a href="../../laika/parse/uri/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="uri/index.html"><span class="name">uri</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li class="current-entities indented2">
                        <a class="object" href="BlockSource$.html" title="Companion for creating BlockSource instances."></a>
                        <a class="class" href="BlockSource.html" title="A block source represents the source for a block level element where each individual line might have a different x-offset to the root source."></a>
                        <a href="BlockSource.html" title="A block source represents the source for a block level element where each individual line might have a different x-offset to the root source.">BlockSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Failure$.html" title=""></a>
                        <a class="class" href="Failure.html" title="The failure case of Parsed containing an error message and the remaining input."></a>
                        <a href="Failure.html" title="The failure case of Parsed containing an error message and the remaining input.">Failure</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="GeneratedSource$.html" title="Represents a generated source, where an AST node has been created programmatically and cannot be traced back to the corresponding input source."></a>
                        <a href="GeneratedSource$.html" title="Represents a generated source, where an AST node has been created programmatically and cannot be traced back to the corresponding input source.">GeneratedSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="LineSource$.html" title="Companion for creating LineSource instances."></a>
                        <a class="class" href="LineSource.html" title="A line source represents all or part of a single line from the root input source."></a>
                        <a href="LineSource.html" title="A line source represents all or part of a single line from the root input source.">LineSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Message$.html" title="Message companion providing several pre-built messages and factory methods."></a>
                        <a class="trait" href="Message.html" title="Represents a lazy failure message."></a>
                        <a href="Message.html" title="Represents a lazy failure message.">Message</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Parsed.html" title="Represents the result of a Parser, a value of type T in case of success, a message in case of failure as well as the SourceCursor for the remaining input."></a>
                        <a href="Parsed.html" title="Represents the result of a Parser, a value of type T in case of success, a message in case of failure as well as the SourceCursor for the remaining input.">Parsed</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="Parser$.html" title="Companion factory for creating new parser instances."></a>
                        <a class="class" href="" title="The abstract base for all parser implementations."></a>
                        <a href="" title="The abstract base for all parser implementations.">Parser</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Position.html" title="Represents an offset into a source string."></a>
                        <a href="Position.html" title="Represents an offset into a source string.">Position</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="RootSource.html" title="A root source represents the full input string of a parsing operation."></a>
                        <a href="RootSource.html" title="A root source represents the full input string of a parsing operation.">RootSource</a>
                      </li><li class="current-entities indented2">
                        <a class="object" href="SourceCursor$.html" title="Companion for creating new SourceCursor instances."></a>
                        <a class="trait" href="SourceCursor.html" title="Represents the state and context of a parsing operation, containing the input string as well as positional information."></a>
                        <a href="SourceCursor.html" title="Represents the state and context of a parsing operation, containing the input string as well as positional information.">SourceCursor</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="trait" href="SourceFragment.html" title="Represents any source cursor other than the root cursor and it is mandated by some APIs that solely deal with recursive parsing where the root input will never be used as the source for the parser."></a>
                        <a href="SourceFragment.html" title="Represents any source cursor other than the root cursor and it is mandated by some APIs that solely deal with recursive parsing where the root input will never be used as the source for the parser.">SourceFragment</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="class" href="Success.html" title="The success case of Parsed containing the result and the remaining input."></a>
                        <a href="Success.html" title="The success case of Parsed containing the result and the remaining input.">Success</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="builders$.html" title="Grouping of all parser builders that allows to construct most common parsers with a single import."></a>
                        <a href="builders$.html" title="Grouping of all parser builders that allows to construct most common parsers with a single import.">builders</a>
                      </li><li class="current-entities indented2">
                        <span class="separator"></span>
                        <a class="object" href="implicits$.html" title="Collection of extension methods that helps keeping parser definitions concise."></a>
                        <a href="implicits$.html" title="Collection of extension methods that helps keeping parser definitions concise.">implicits</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="class type">
      <div id="definition">
        <a href="Parser$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a>
        <p id="owner"><a href="../index.html" class="extype" name="laika">laika</a>.<a href="index.html" class="extype" name="laika.parse">parse</a></p>
        <h1><a href="Parser$.html" title="See companion object">Parser</a><span class="permalink">
      <a href="../../laika/parse/Parser.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"><div>
            Companion <a href="Parser$.html" title="See companion object">object Parser</a>
          </div></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p> The abstract base for all parser implementations.</p><p> Contains the main <code>parse</code> function as well as various
 combinator function to create a new parser based on this one.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
            <span class="toggle">
              Known Subclasses
            </span>
            <div class="subClasses hiddenContent"><a href="code/common/CharLiteral$$CharParser.html" class="extype" name="laika.parse.code.common.CharLiteral.CharParser">CharParser</a>, <a href="code/common/CodeParserBase.html" class="extype" name="laika.parse.code.common.CodeParserBase">CodeParserBase</a>, <a href="code/common/Identifier$$IdParser.html" class="extype" name="laika.parse.code.common.Identifier.IdParser">IdParser</a>, <a href="code/common/NumberLiteral$$NumericParser.html" class="extype" name="laika.parse.code.common.NumberLiteral.NumericParser">NumericParser</a>, <a href="code/common/StringLiteral$$StringParser.html" class="extype" name="laika.parse.code.common.StringLiteral.StringParser">StringParser</a>, <a href="code/common/TagParser.html" class="extype" name="laika.parse.code.common.TagParser">TagParser</a>, <a href="combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>, <a href="markup/InlineParser.html" class="extype" name="laika.parse.markup.InlineParser">InlineParser</a>, <a href="text/Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>, <a href="text/DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a>, <a href="text/DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a>, <a href="text/Literal.html" class="extype" name="laika.parse.text.Literal">Literal</a>, <a href="text/PrefixCharacters.html" class="extype" name="laika.parse.text.PrefixCharacters">PrefixCharacters</a>, <a href="text/PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a></div>
          </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="laika.parse.Parser"><span>Parser</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="laika.parse.Parser#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;():laika.parse.Parser[T]"></a><a id="&lt;init&gt;:Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#&lt;init&gt;():laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="params">()</span>
      </span>
      
      
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="laika.parse.Parser#parse" visbl="pub" class="indented0 " data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="parse(in:laika.parse.SourceCursor):laika.parse.Parsed[T]"></a><a id="parse(SourceCursor):Parsed[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#parse(in:laika.parse.SourceCursor):laika.parse.Parsed[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="params">(<span name="in">in: <a href="SourceCursor.html" class="extype" name="laika.parse.SourceCursor">SourceCursor</a></span>)</span><span class="result">: <a href="Parsed.html" class="extype" name="laika.parse.Parsed">Parsed</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the string content in the specified context
and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the string content in the specified context
and returns the result.</p><p>This is the only abstract method in <code>Parser</code> that
concrete implementations need to implement.
</p></div></div>
    </li></ol>
            </div>

        <div class="values members">
              <h3>Concrete Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#*" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="*:laika.parse.combinator.Repeat[T]"></a><a id="*:Repeat[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#*:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times" class="name">*</span><span class="result">: <a href="combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that repeatedly applies this parser.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that repeatedly applies this parser.
 It will always succeed, potentially with an empty list as the result.
</p></div></div>
    </li><li name="laika.parse.Parser#+" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="+:laika.parse.combinator.Repeat[T]"></a><a id="+:Repeat[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#+:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus" class="name">+</span><span class="result">: <a href="combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser (at least once).</p>
    </li><li name="laika.parse.Parser#&lt;~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T]"></a><a id="&lt;~[U](Parser[U]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#&lt;~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$tilde" class="name">&lt;~</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&lt;~.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser,
 but only keeps the left result.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser,
 but only keeps the left result.</p><p> <code>a &lt;~ b</code> only succeeds if both parsers succeed.
</p></div></div>
    </li><li name="laika.parse.Parser#&lt;~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;~(value:String):laika.parse.Parser[T]"></a><a id="&lt;~(String):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#&lt;~(value:String):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $less$tilde" class="name">&lt;~</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the left result.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the left result.</p><p><code>a &lt;~ b</code> only succeeds if both parsers succeed.
</p></div></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#&gt;&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&gt;&gt;[U](fq:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="&gt;&gt;[U]((T)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#&gt;&gt;[U](fq:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $greater$greater" class="name">&gt;&gt;</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="fq">fq: (<span class="extype" name="laika.parse.Parser.T">T</span>) ⇒ <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&gt;&gt;.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.&gt;&gt;.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Operator synonym for <code>flatMap</code>.</p>
    </li><li name="laika.parse.Parser#?" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="?:laika.parse.Parser[Option[T]]"></a><a id="?:Parser[Option[T]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#?:laika.parse.Parser[Option[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $qmark" class="name">?</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.Parser.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that optionally parses what this parser parses.</p>
    </li><li name="laika.parse.Parser#^^" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="^^[U](f:T=&gt;U):laika.parse.Parser[U]"></a><a id="^^[U]((T)⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#^^[U](f:T=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $up$up" class="name">^^</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.Parser.T">T</span>) ⇒ <span class="extype" name="laika.parse.Parser.^^.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.^^.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A synonym for <code>map</code>, allowing the grammar to be declared in a concise way.</p>
    </li><li name="laika.parse.Parser#as" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="as[U](v:=&gt;U):laika.parse.Parser[U]"></a><a id="as[U](⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#as[U](v:=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">as</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="v">v: ⇒ <span class="extype" name="laika.parse.Parser.as.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.as.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that ignores the result of this parser (if it succeeds)
 and returns the specified result instead.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that ignores the result of this parser (if it succeeds)
 and returns the specified result instead.</p><p> Subclasses may override this method to avoid any expensive
 result processing.
</p></div></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#collect" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="collect[U,V&gt;:T](f:PartialFunction[T,U],error:V=&gt;String):laika.parse.Parser[U]"></a><a id="collect[U,V&gt;:T](PartialFunction[T,U],(V)⇒String):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#collect[U,V&gt;:T](f:PartialFunction[T,U],error:V=&gt;String):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">collect</span><span class="tparams">[<span name="U">U</span>, <span name="V">V &gt;: <span class="extype" name="laika.parse.Parser.T">T</span></span>]</span><span class="params">(<span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<span class="extype" name="laika.parse.Parser.T">T</span>, <span class="extype" name="laika.parse.Parser.collect.U">U</span>]</span>, <span name="error">error: (<span class="extype" name="laika.parse.Parser.collect.V">V</span>) ⇒ <span class="extype" name="scala.Predef.String">String</span> = <span class="defval" name="(r: V) =&gt; s&quot;Constructor function not defined at $r&quot;">...</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.collect.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that applies a partial function to the result of this parser.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that applies a partial function to the result of this parser.</p><p><code>p.collect(f)</code> succeeds if <code>p</code> succeeds and <code>f</code> is defined at the result of <code>p</code>,
In that case it returns <code>f</code> applied to the result of <code>p</code>.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a partial function that will be applied to this parser's result.</p></dd><dt class="param">error</dt><dd class="cmt"><p>an optional function that takes the same argument as <code>f</code> and produces an error message.</p></dd></dl></div>
    </li><li name="laika.parse.Parser#count" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="count:laika.parse.Parser[Int]"></a><a id="count:Parser[Int]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#count:laika.parse.Parser[Int]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">count</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Int">Int</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that produces the number of characters
consumed by this parser while discarding the original result.</p>
    </li><li name="laika.parse.Parser#cursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cursor:laika.parse.Parser[laika.parse.SourceFragment]"></a><a id="cursor:Parser[SourceFragment]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#cursor:laika.parse.Parser[laika.parse.SourceFragment]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cursor</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<a href="SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Provides a cursor over the input consumed by this parser while discarding the actual result.</p><div class="fullcomment"><div class="comment cmt"><p>Provides a cursor over the input consumed by this parser while discarding the actual result.
Use <code>withCursor</code> if you also need access to the result.</p><p>This is required for parsers that create AST nodes that need to be resolved in a rewrite step
and need to report the source location in case of failure.
It is also required when passing a result of a first-pass parser to a recursive parser
to preserve line positions.
</p></div></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#evalMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="evalMap[U](f:T=&gt;Either[String,U]):laika.parse.Parser[U]"></a><a id="evalMap[U]((T)⇒Either[String,U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#evalMap[U](f:T=&gt;Either[String,U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">evalMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.Parser.T">T</span>) ⇒ <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="laika.parse.Parser.evalMap.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.evalMap.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that applies a function to the result of this parser producing an <code>Either</code>
 where <code>Left</code> is interpreted as failure.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that applies a function to the result of this parser producing an <code>Either</code>
 where <code>Left</code> is interpreted as failure. It is an alternative to <code>^?<code> for scenarios
 where the conditional check cannot be easily performed in a pattern match.</code></code></p><p> <code>p.evalMap(f)</code> succeeds if <code>p</code> succeeds and <code>f</code> returns a <code>Right</code> when applied to the result
 of <code>p</code>.
</p></div></div>
    </li><li name="laika.parse.Parser#flatMap" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="flatMap[U](f:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="flatMap[U]((T)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#flatMap[U](f:T=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.Parser.T">T</span>) ⇒ <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.flatMap.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.flatMap.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new parser by applying the specified function
to the result of this parser and subsequently applying
the parser returned by that function to the input left
over by this parser.</p>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#handleErrorWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="handleErrorWith[U&gt;:T]((Failure)⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleErrorWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.Parser.T">T</span></span>]</span><span class="params">(<span name="f">f: (<a href="Failure.html" class="extype" name="laika.parse.Failure">Failure</a>) ⇒ <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.handleErrorWith.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.handleErrorWith.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Handle any error, potentially recovering from it, by mapping it to a new parser that
will be applied at the same starting position than the failing parser.</p><div class="fullcomment"><div class="comment cmt"><p>Handle any error, potentially recovering from it, by mapping it to a new parser that
will be applied at the same starting position than the failing parser.</p><p>This is similar to the <code>orElse</code> or <code>|</code> method, but allows the alternative
parser to inspect the error of the preceding one.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="#recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]" class="extmbr" name="laika.parse.Parser#recoverWith">recoverWith</a> to recover from only certain errors.</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.Parser#map" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="map[U](f:T=&gt;U):laika.parse.Parser[U]"></a><a id="map[U]((T)⇒U):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#map[U](f:T=&gt;U):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="laika.parse.Parser.T">T</span>) ⇒ <span class="extype" name="laika.parse.Parser.map.U">U</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.map.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Builds a new parser by applying the specified function
to the result of this parser.</p>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#orElse" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="orElse[U&gt;:T](p0:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="orElse[U&gt;:T](⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#orElse[U&gt;:T](p0:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">orElse</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.Parser.T">T</span></span>]</span><span class="params">(<span name="p0">p0: ⇒ <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.orElse.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.orElse.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser when this parser fails.</p><p> <code>a orElse b</code> succeeds if either of the parsers succeeds.</p><p> In case both parsers fail, the <code>Failure</code> instance will
 be from the parser with the most successfully read characters.
 In the case of multiple failures having the same number of characters,
 the one with the highest precedence (this parser) will be chosen.</p><p> Implementation note:
 The parameter is by-name to allow the definition of
 recursive parsers. In contrast to the former SDK
 parser combinators this is the only place where
 a parser with a by-name parameter is used whereas
 in all other places the additional cost is avoided.
</p></div></div>
    </li><li name="laika.parse.Parser#parse" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="parse(in:String):laika.parse.Parsed[T]"></a><a id="parse(String):Parsed[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#parse(in:String):laika.parse.Parsed[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="params">(<span name="in">in: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="Parsed.html" class="extype" name="laika.parse.Parsed">Parsed</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the specified string and returns the result.</p>
    </li><li name="laika.parse.Parser#recoverWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]"></a><a id="recoverWith[U&gt;:T](PartialFunction[Failure,Parser[U]]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#recoverWith[U&gt;:T](pf:PartialFunction[laika.parse.Failure,laika.parse.Parser[U]]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">recoverWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.Parser.T">T</span></span>]</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="Failure.html" class="extype" name="laika.parse.Failure">Failure</a>, <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.recoverWith.U">U</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.recoverWith.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Handle certain errors, potentially recovering from it, by mapping them to a new parser that
will be applied at the same starting position than the failing parser.</p><div class="fullcomment"><div class="comment cmt"><p>Handle certain errors, potentially recovering from it, by mapping them to a new parser that
will be applied at the same starting position than the failing parser.
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p><a href="#handleErrorWith[U&gt;:T](f:laika.parse.Failure=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" class="extmbr" name="laika.parse.Parser#handleErrorWith">handleErrorWith</a> to handle any/all errors.</p></span></dd></dl></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep(separator:String):laika.parse.combinator.Repeat[T]"></a><a id="rep(String):Repeat[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#rep(separator:String):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="params">(<span name="separator">separator: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser with the specified
separator string between those invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser with the specified
separator string between those invocations.</p><p><code>p.rep(sep).min(1)</code> is equivalent to <code>(p ~ (sep ~&gt; p).rep).concat</code>.</p><p>The returned parser offers an API to specify further constraints
like <code>min</code> or <code>max</code>.
</p></div></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep(separator:laika.parse.Parser[Unit]):laika.parse.combinator.Repeat[T]"></a><a id="rep(Parser[Unit]):Repeat[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#rep(separator:laika.parse.Parser[Unit]):laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="params">(<span name="separator">separator: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>)</span><span class="result">: <a href="combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser with the specified
separator parser between those invocations.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser with the specified
separator parser between those invocations.</p><p><code>p.rep(sep).min(1)</code> is equivalent to <code>(p ~ (sep ~&gt; p).rep).concat</code>.</p><p>The returned parser offers an API to specify further constraints
like <code>min</code> or <code>max</code>.
</p></div></div>
    </li><li name="laika.parse.Parser#rep" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep:laika.parse.combinator.Repeat[T]"></a><a id="rep:Repeat[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#rep:laika.parse.combinator.Repeat[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="result">: <a href="combinator/Repeat.html" class="extype" name="laika.parse.combinator.Repeat">Repeat</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Returns a parser that repeatedly applies this parser.</p><div class="fullcomment"><div class="comment cmt"><p> Returns a parser that repeatedly applies this parser.
 The returned parser offers an API to specify further constraints
 like <code>min</code> or <code>max</code>.
</p></div></div>
    </li><li name="laika.parse.Parser#repUntil" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repUntil[U](endCondition:laika.parse.Parser[U]):laika.parse.Parser[(List[T],Option[U])]"></a><a id="repUntil[U](Parser[U]):Parser[(List[T],Option[U])]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#repUntil[U](endCondition:laika.parse.Parser[U]):laika.parse.Parser[(List[T],Option[U])]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repUntil</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="endCondition">endCondition: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.repUntil.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.Parser.T">T</span>], <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.Parser.repUntil.U">U</span>])]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that repeatedly applies this parser until either this parser fails or the specified
end condition is met.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that repeatedly applies this parser until either this parser fails or the specified
end condition is met.
The end condition will be applied after each successful invocation of this parser.</p><p>The result of the returned parser is a tuple consisting of the list containing the
result of the invocations of this parser plus the result of the end condition.
The latter is returned as an <code>Option</code> as it might be empty when the parsing finished because of this parser failing.</p><p>Note that it is more convenient to include the end condition in the repeating parser itself and use
the simpler <code>rep</code> method.
This combinator is an alternative if you need to know the result of the end condition.
</p></div></div>
    </li><li name="laika.parse.Parser#repWith" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repWith[U&gt;:T](next:U=&gt;laika.parse.Parser[U]):laika.parse.Parser[List[U]]"></a><a id="repWith[U&gt;:T]((U)⇒Parser[U]):Parser[List[U]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#repWith[U&gt;:T](next:U=&gt;laika.parse.Parser[U]):laika.parse.Parser[List[U]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repWith</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.Parser.T">T</span></span>]</span><span class="params">(<span name="next">next: (<span class="extype" name="laika.parse.Parser.repWith.U">U</span>) ⇒ <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.repWith.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.Parser.repWith.U">U</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Returns a parser that invokes the specified function repeatedly,
passing the result of this parser if it succeeds, to produce new
parsers that get applied until one of them fails.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a parser that invokes the specified function repeatedly,
passing the result of this parser if it succeeds, to produce new
parsers that get applied until one of them fails.</p><p>The result of the returned parser is a list containing the
result of this parser (if it succeeds) plus the results of
successful invocations of the parsers returned by the specified
function.
</p></div></div>
    </li><li name="laika.parse.Parser#source" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="source:laika.parse.Parser[String]"></a><a id="source:Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#source:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">source</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Retrieves the part of the input consumed by this parser while discarding the result.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves the part of the input consumed by this parser while discarding the result.</p><p>This is useful in scenarios where many string-based parsers are combined and produce a deeply nested result
like <code>String ~ Option[String] ~ List[String]</code> where it would require some boilerplate to concatenate the results.
Using the source method, the entire text consumed by this combination of parsers will be returned.</p><p>If you also need the position within the input or need to pass the result to a recursive parser manually,
use the <code>cursor</code> method instead.
</p></div></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.Parser#void" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="void:laika.parse.Parser[Unit]"></a><a id="void:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#void:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">void</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Discards the result of a successful parser.</p>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.Parser#withCursor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withCursor:laika.parse.Parser[(T,laika.parse.SourceFragment)]"></a><a id="withCursor:Parser[(T,SourceFragment)]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#withCursor:laika.parse.Parser[(T,laika.parse.SourceFragment)]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withCursor</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[(<span class="extype" name="laika.parse.Parser.T">T</span>, <a href="SourceFragment.html" class="extype" name="laika.parse.SourceFragment">SourceFragment</a>)]</span>
      </span>
      
      <p class="shortcomment cmt">Provides the result of this parser together with a cursor over the input,
capturing the consumed source string and its position within the root input.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the result of this parser together with a cursor over the input,
capturing the consumed source string and its position within the root input.
Use <code>cursor</code> if you do not need access to the actual result.</p><p>This is required for parsers that create AST nodes that need to be resolved in a rewrite step
and need to report the source location in case of failure.
It is also required when passing a result of a first-pass parser to a recursive parser
to preserve line positions.
</p></div></div>
    </li><li name="laika.parse.Parser#withFailureMessage" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="withFailureMessage(msg:String):laika.parse.Parser[T]"></a><a id="withFailureMessage(String):Parser[T]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#withFailureMessage(msg:String):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFailureMessage</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Changes the failure message produced by a parser.</p>
    </li><li name="laika.parse.Parser#|" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="|(value:String)(implicitev:T&lt;:&lt;String):laika.parse.Parser[String]"></a><a id="|(String)(&lt;:&lt;[T,String]):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#|(value:String)(implicitev:T&lt;:&lt;String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bar" class="name">|</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span class="extype" name="scala.Predef.&lt;:&lt;">&lt;:&lt;</span>[<span class="extype" name="laika.parse.Parser.T">T</span>, <span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Attempts to parse the specified literal string when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Attempts to parse the specified literal string when this parser fails.</p><p> <code>a | b</code> succeeds if either of the parsers succeeds.
</p></div></div>
    </li><li name="laika.parse.Parser#|" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="|[U&gt;:T](p:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="|[U&gt;:T](⇒Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#|[U&gt;:T](p:=&gt;laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bar" class="name">|</span><span class="tparams">[<span name="U">U &gt;: <span class="extype" name="laika.parse.Parser.T">T</span></span>]</span><span class="params">(<span name="p">p: ⇒ <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.|.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.|.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser when this parser fails.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser when this parser fails.</p><p> <code>a | b</code> succeeds if either of the parsers succeeds.</p><p> Implementation note:
 The parameter is by-name to allow the definition of
 recursive parsers. In contrast to the former SDK
 parser combinators this is the only place where
 a parser with a by-name parameter is used whereas
 in all other places the additional cost is avoided.
</p></div></div>
    </li><li name="laika.parse.Parser#~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T~U]"></a><a id="~[U](Parser[U]):Parser[~[T,U]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#~[U](p:laika.parse.Parser[U]):laika.parse.Parser[T~U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../ast/package$$$tilde.html" class="extype" name="laika.ast.~">~</a>[<span class="extype" name="laika.parse.Parser.T">T</span>, <span class="extype" name="laika.parse.Parser.~.U">U</span>]]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser
 and combines the two results.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser
 and combines the two results.</p><p> <code>a ~ b</code> only succeeds if both parsers succeed, with the results
 in a wrapper class named <code>~</code> for convenient pattern matching:</p><pre>a ~ b ~ c ^^ {
  <span class="kw">case</span> a ~ b ~ c <span class="kw">=&gt;</span> processResult(a, b, c)
}</pre></div></div>
    </li><li name="laika.parse.Parser#~" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~(value:String):laika.parse.Parser[T~String]"></a><a id="~(String):Parser[~[T,String]]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#~(value:String):laika.parse.Parser[T~String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<a href="../ast/package$$$tilde.html" class="extype" name="laika.ast.~">~</a>[<span class="extype" name="laika.parse.Parser.T">T</span>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over
by this parser and combines the two results.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over
by this parser and combines the two results.</p><p> <code>a ~ b</code> only succeeds if both parsers succeed, with the results
 in a wrapper class named <code>~</code> for convenient pattern matching:</p><pre>a ~ b ~ c ^^ {
  <span class="kw">case</span> a ~ b ~ c <span class="kw">=&gt;</span> processResult(a, b, c)
}</pre></div></div>
    </li><li name="laika.parse.Parser#~&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~&gt;[U](p:laika.parse.Parser[U]):laika.parse.Parser[U]"></a><a id="~&gt;[U](Parser[U]):Parser[U]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#~&gt;[U](p:laika.parse.Parser[U]):laika.parse.Parser[U]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde$greater" class="name">~&gt;</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="p">p: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~&gt;.U">U</span>]</span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.Parser.~&gt;.U">U</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser to the input left over by this parser,
 but only keeps the right result.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser to the input left over by this parser,
 but only keeps the right result.</p><p> <code>a ~&gt; b</code> only succeeds if both parsers succeed.
</p></div></div>
    </li><li name="laika.parse.Parser#~&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~&gt;(value:String):laika.parse.Parser[String]"></a><a id="~&gt;(String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#~&gt;(value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde$greater" class="name">~&gt;</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the right result.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal string from the input left over by this parser,
but only keeps the right result.</p><p> <code>a ~&gt; b</code> only succeeds if both parsers succeed.
</p></div></div>
    </li>
              </ol>
            </div>

        

        <div class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../laika/parse/Parser.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: ">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
                <span class="name">@Deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
