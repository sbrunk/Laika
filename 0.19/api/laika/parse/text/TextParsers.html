<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.laika" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="laika"></a><a id="laika:laika"></a>
      <span class="permalink">
      <a href="../../../laika/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">laika</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="laika.parse" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse"></a><a id="parse:parse"></a>
      <span class="permalink">
      <a href="../../../laika/parse/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">parse</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="laika">laika</a></dd></dl></div>
    </li><li name="laika.parse.text" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text"></a><a id="text:text"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">text</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="laika.parse">parse</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="object" href="CharGroup$.html" title="Common groups of characters as input for parser definitions."></a>
                        <a href="CharGroup$.html" title="Common groups of characters as input for parser definitions.">CharGroup</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="Characters$.html" title="Companion with factory methods for creating optimized character parsers."></a>
                        <a class="class" href="Characters.html" title="Optimized parser for character input."></a>
                        <a href="Characters.html" title="Optimized parser for character input.">Characters</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="DelimitedText$.html" title=""></a>
                        <a class="class" href="DelimitedText.html" title="A parser for text that ends with a specific delimiter condition, either marking the end of the text span or the start of an embedded inner span."></a>
                        <a href="DelimitedText.html" title="A parser for text that ends with a specific delimiter condition, either marking the end of the text span or the start of an embedded inner span.">DelimitedText</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="DelimiterParser.html" title="A parser that simplifies the expression of typical conditions for start and end delimiters of inline spans."></a>
                        <a href="DelimiterParser.html" title="A parser that simplifies the expression of typical conditions for start and end delimiters of inline spans.">DelimiterParser</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="Literal.html" title="A parser that matches a literal string."></a>
                        <a href="Literal.html" title="A parser that matches a literal string.">Literal</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="PrefixCharacters.html" title="A variant of the Characters type that can be used as a stable prefix for an optimized span parser as it is always non-empty."></a>
                        <a href="PrefixCharacters.html" title="A variant of the Characters type that can be used as a stable prefix for an optimized span parser as it is always non-empty.">PrefixCharacters</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="PrefixedParser$.html" title="Factories and utilities for creating or processing PrefixedParser instances."></a>
                        <a class="trait" href="PrefixedParser.html" title="A parser that is associated with a non-empty set of trigger characters for performance optimizations."></a>
                        <a href="PrefixedParser.html" title="A parser that is associated with a non-empty set of trigger characters for performance optimizations.">PrefixedParser</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="TextParsers$.html" title="Instance that allows to import all text parsers in isolation."></a>
                        <a class="trait" href="" title="Base text parsers that provide optimized low-level parsers for typical requirements of text markup parsers."></a>
                        <a href="" title="Base text parsers that provide optimized low-level parsers for typical requirements of text markup parsers.">TextParsers</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="WhitespacePreprocessor$.html" title="Companion for creating instances of WhitespacePreprocessor."></a>
                        <a class="class" href="WhitespacePreprocessor.html" title="Processes whitespace, removing or replacing most whitespace characters except for newline and space."></a>
                        <a href="WhitespacePreprocessor.html" title="Processes whitespace, removing or replacing most whitespace characters except for newline and space.">WhitespacePreprocessor</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="trait type">
      <div id="definition">
        <a href="TextParsers$.html" title="See companion object"><div class="big-circle trait-companion-object">t</div></a>
        <p id="owner"><a href="../../index.html" class="extype" name="laika">laika</a>.<a href="../index.html" class="extype" name="laika.parse">parse</a>.<a href="index.html" class="extype" name="laika.parse.text">text</a></p>
        <h1><a href="TextParsers$.html" title="See companion object">TextParsers</a><span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"><div>
            Companion <a href="TextParsers$.html" title="See companion object">object TextParsers</a>
          </div></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">TextParsers</span><span class="result"> extends <a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Base text parsers that provide optimized low-level parsers for typical requirements
 of text markup parsers. In particular they are meant as an efficient replacement
 for scenarios where usually regex parsers are used. In cases where different parsers
 need to be tried for relatively short input sequences, regex parsers tend to be less
 efficient. Furthermore, these base parsers may also improve readability, as it
 allows to combine simple low-level parsers to higher-level parsers based on the
 Laika combinator API, instead of producing long regexes which may be hard to read.
</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
            <span class="toggle">
              Known Subclasses
            </span>
            <div class="subClasses hiddenContent"><a href="../builders$.html" class="extype" name="laika.parse.builders">builders</a>, <a href="TextParsers$.html" class="extype" name="laika.parse.text.TextParsers">TextParsers</a></div>
          </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="laika.parse.text.TextParsers"><span>TextParsers</span></li><li class="in" name="laika.parse.combinator.Parsers"><span>Parsers</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.parse.combinator.Parsers.ParserException" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParserExceptionextendsRuntimeExceptionwithProductwithSerializable"></a><a id="ParserException:ParserException"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Parsers$ParserException.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a title="" href="../combinator/Parsers$ParserException.html"><span class="name">ParserException</span></a><span class="params">(<span name="result">result: <a href="../Failure.html" class="extype" name="laika.parse.Failure">Failure</a></span>)</span><span class="result"> extends <span class="extype" name="scala.RuntimeException">RuntimeException</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers.TryOps" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TryOps[A]extendsAnyRef"></a><a id="TryOps[A]:TryOps[A]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/combinator/Parsers$TryOps.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Provides additional methods to Try via implicit conversion." href="../combinator/Parsers$TryOps.html"><span class="name">TryOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <p class="shortcomment cmt">Provides additional methods to <code>Try</code> via implicit conversion.</p><div class="fullcomment"><div class="comment cmt"><p>Provides additional methods to <code>Try</code> via implicit conversion.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#anyChars" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyChars:laika.parse.text.Characters[String]"></a><a id="anyChars:Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#anyChars:laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">anyChars</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#anyNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]"></a><a id="anyNot(NonEmptySet[Char]):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#anyNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences that are not one of the specified characters.
Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#anyNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyNot(char:Char,chars:Char*):laika.parse.text.Characters[String]"></a><a id="anyNot(Char,Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#anyNot(char:Char,chars:Char*):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#anyOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]"></a><a id="anyOf(NonEmptySet[Char]):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#anyOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#anyOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(char:Char,chars:Char*):laika.parse.text.Characters[String]"></a><a id="anyOf(Char,Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#anyOf(char:Char,chars:Char*):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#anyWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]"></a><a id="anyWhile((Char)⇒Boolean):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#anyWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
Always succeeds unless a minimum number of required matches is specified.
</p></div></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#atStart" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="atStart:laika.parse.Parser[Unit]"></a><a id="atStart:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#atStart:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the start of the input.</p>
    </li><li name="laika.parse.text.TextParsers#blankLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blankLine:laika.parse.Parser[String]"></a><a id="blankLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#blankLine:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLine</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a blank line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a blank line from the current input offset (which may not be at the
 start of the line). Fails for lines that contain any non-whitespace character.
 Does always produce an empty string as the result, discarding any whitespace
 characters found in the line.</p><p> Since it also succeeds at the end of the input
 it should never be used in the form of <code>(blankLine *)</code> or <code>(blankLine +)</code>. Use
 the <code>blankLines</code> parser instead in these cases.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#blankLines" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="blankLines:laika.parse.Parser[List[String]]"></a><a id="blankLines:Parser[List[String]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#blankLines:laika.parse.Parser[List[String]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLines</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Parses one or more blank lines, producing a list of empty strings corresponding
to the number of blank lines consumed.</p>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#consumeAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="consumeAll[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="consumeAll[T](Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#consumeAll[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">consumeAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.consumeAll.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.consumeAll.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that succeeds if the specified parser succeeds and all input has been consumed.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that succeeds if the specified parser succeeds and all input has been consumed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimitedBy(delimiter:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimitedText"></a><a id="delimitedBy(PrefixedParser[String]):DelimitedText"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimitedBy(delimiter:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="delimiter">delimiter: <a href="PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until the specified delimiter parser
succeeds on the input.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters until the specified delimiter parser
succeeds on the input.</p><p>This constructor is limited to the sub-trait <code>PrefixedParser</code>
as only those can be optimized for an assertion that needs to be performed on each
character. Most parsers for non-empty text implement this trait, e.g <code>oneOf</code>, <code>someOf</code>,
<code>delimiter</code> or the literal parsers for a character or string.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimitedBy(str:String):laika.parse.text.DelimitedText"></a><a id="delimitedBy(String):DelimitedText"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimitedBy(str:String):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="str">str: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until the specified string delimiter
is encountered on the input string.</p>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimitedBy(chars:cats.data.NonEmptySet[Char]):laika.parse.text.DelimitedText"></a><a id="delimitedBy(NonEmptySet[Char]):DelimitedText"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimitedBy(chars:cats.data.NonEmptySet[Char]):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.</p>
    </li><li name="laika.parse.text.TextParsers#delimitedBy" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimitedBy(char:Char,chars:Char*):laika.parse.text.DelimitedText"></a><a id="delimitedBy(Char,Char*):DelimitedText"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimitedBy(char:Char,chars:Char*):laika.parse.text.DelimitedText" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimitedBy</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="DelimitedText.html" class="extype" name="laika.parse.text.DelimitedText">DelimitedText</a></span>
      </span>
      
      <p class="shortcomment cmt">Consumes any number of consecutive characters until one of the specified characters
is encountered on the input string.</p>
    </li><li name="laika.parse.text.TextParsers#delimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="delimiter(parser:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimiterParser"></a><a id="delimiter(PrefixedParser[String]):DelimiterParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimiter(parser:laika.parse.text.PrefixedParser[String]):laika.parse.text.DelimiterParser" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimiter</span><span class="params">(<span name="parser">parser: <a href="PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a parser for a delimiter with an API that allows to specify
predicates for the characters immediately preceding or following
the delimiter, a common task in markup parsing.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a parser for a delimiter with an API that allows to specify
predicates for the characters immediately preceding or following
the delimiter, a common task in markup parsing.</p><p>This specified underlying parser needs to implement the sub-trait <code>PrefixedParser</code>
as only those can be optimized for an assertion that needs to be performed on each
character. Most parsers for non-empty text implement this trait, e.g <code>oneOf</code>, <code>someOf</code>,
<code>delimiter</code> or the literal parsers for a character or string.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#delimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimiter(delim:String):laika.parse.text.DelimiterParser"></a><a id="delimiter(String):DelimiterParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimiter(delim:String):laika.parse.text.DelimiterParser" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimiter</span><span class="params">(<span name="delim">delim: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a parser for a delimiter based on a literal string with an API that
allows to specify predicates for the characters immediately
preceding or following the delimiter, a common task in markup parsing.</p>
    </li><li name="laika.parse.text.TextParsers#delimiter" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="delimiter(char:Char,chars:Char*):laika.parse.text.DelimiterParser"></a><a id="delimiter(Char,Char*):DelimiterParser"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#delimiter(char:Char,chars:Char*):laika.parse.text.DelimiterParser" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">delimiter</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="DelimiterParser.html" class="extype" name="laika.parse.text.DelimiterParser">DelimiterParser</a></span>
      </span>
      
      <p class="shortcomment cmt">Creates a parser for a delimiter based on the given set of delimiter characters
with an API that allows to specify predicates for the characters immediately
preceding or following the delimiter, a common task in markup parsing.</p>
    </li><li name="laika.parse.text.TextParsers#eof" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="eof:laika.parse.Parser[String]"></a><a id="eof:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#eof:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the end of the input.</p>
    </li><li name="laika.parse.text.TextParsers#eol" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eol:laika.parse.Parser[Unit]"></a><a id="eol:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#eol:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#failure" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="failure(msg:String):laika.parse.Parser[Nothing]"></a><a id="failure(String):Parser[Nothing]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#failure(msg:String):laika.parse.Parser[Nothing]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that always fails with the specified message.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that always fails with the specified message.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lazily" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lazily[T](p:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lazily[T](⇒Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#lazily[T](p:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lazily</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lazily.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lazily.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Constructs a parser lazily, useful when breaking circles in recursive parsing.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a parser lazily, useful when breaking circles in recursive parsing.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#literal" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="literal(expected:String):laika.parse.text.PrefixedParser[String]"></a><a id="literal(String):PrefixedParser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#literal(expected:String):laika.parse.text.PrefixedParser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> A parser that matches only the specified literal string.</p><div class="fullcomment"><div class="comment cmt"><p> A parser that matches only the specified literal string.</p><p> The method is implicit so that strings can automatically be lifted to their parsers.
</p></div></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead(offset:Int,value:String):laika.parse.Parser[String]"></a><a id="lookAhead(Int,String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#lookAhead(offset:Int,value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal value at the specified offset
behind the current position.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal value at the specified offset
behind the current position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead[T](offset:Int,p:laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lookAhead[T](Int,Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#lookAhead[T](offset:Int,p:laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead(value:String):laika.parse.Parser[String]"></a><a id="lookAhead(String):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#lookAhead(value:String):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Attempts to parse the specified literal value at the current
position.</p><div class="fullcomment"><div class="comment cmt"><p>Attempts to parse the specified literal value at the current
position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookAhead" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookAhead[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lookAhead[T](Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#lookAhead[T](p:laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookAhead</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookAhead.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt"> Applies the specified parser at the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p> Applies the specified parser at the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#lookBehind" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookBehind[T](offset:Int,parser:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]"></a><a id="lookBehind[T](Int,⇒Parser[T]):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#lookBehind[T](offset:Int,parser:=&gt;laika.parse.Parser[T]):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="parser">parser: ⇒ <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookBehind.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.lookBehind.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#nextIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="nextIn(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#nextIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextIn</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is one of those specified.
Fails at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#nextIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextIn(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="nextIn(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#nextIn(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextIn</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is one of those specified.
Fails at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#nextIs" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="nextIs((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#nextIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextIs</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character does not satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character does not satisfy the specified predicate.
Fails at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#nextNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="nextNot((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#nextNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextNot</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character does not satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character does not satisfy the specified predicate.
Succeeds at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#nextNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="nextNot(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#nextNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is not one of those specified.
Succeeds at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#nextNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nextNot(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="nextNot(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#nextNot(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nextNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the next character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the next character is not one of those specified.
Succeeds at the end of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.combinator.Parsers#not" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not(value:String):laika.parse.Parser[Unit]"></a><a id="not(String):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#not(value:String):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that only succeeds if the parsing the specified literal value
fails and vice versa, it never consumes any input.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that only succeeds if the parsing the specified literal value
fails and vice versa, it never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#not" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not[T](p:laika.parse.Parser[T]):laika.parse.Parser[Unit]"></a><a id="not[T](Parser[T]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#not[T](p:laika.parse.Parser[T]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.not.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that only succeeds if the specified parser fails and
 vice versa, it never consumes any input.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that only succeeds if the specified parser fails and
 vice versa, it never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@HotSpotIntrinsicCandidate</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#oneChar" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="oneChar:laika.parse.Parser[String]"></a><a id="oneChar:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#oneChar:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">oneChar</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses exactly one character from the input, fails only at the end of the input.</p>
    </li><li name="laika.parse.text.TextParsers#oneIf" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="oneIf(p:Char=&gt;Boolean):laika.parse.Parser[String]"></a><a id="oneIf((Char)⇒Boolean):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#oneIf(p:Char=&gt;Boolean):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneIf</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it satisfies the specified predicate, fails otherwise.</p>
    </li><li name="laika.parse.text.TextParsers#oneNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="oneNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[String]"></a><a id="oneNot(NonEmptySet[Char]):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#oneNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it is not one of the specified characters.</p>
    </li><li name="laika.parse.text.TextParsers#oneNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="oneNot(char:Char,chars:Char*):laika.parse.Parser[String]"></a><a id="oneNot(Char,Char*):Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#oneNot(char:Char,chars:Char*):laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it is not one of the specified characters.</p>
    </li><li name="laika.parse.text.TextParsers#oneOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="oneOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixedParser[String]"></a><a id="oneOf(NonEmptySet[Char]):PrefixedParser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#oneOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixedParser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it matches one of the specified characters, fails otherwise.</p>
    </li><li name="laika.parse.text.TextParsers#oneOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="oneOf(char:Char,chars:Char*):laika.parse.text.PrefixedParser[String]"></a><a id="oneOf(Char,Char*):PrefixedParser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#oneOf(char:Char,chars:Char*):laika.parse.text.PrefixedParser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">oneOf</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="PrefixedParser.html" class="extype" name="laika.parse.text.PrefixedParser">PrefixedParser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one character if it matches one of the specified characters, fails otherwise.</p>
    </li><li name="laika.parse.combinator.Parsers#opt" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt(value:String):laika.parse.Parser[Option[String]]"></a><a id="opt(String):Parser[Option[String]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#opt(value:String):laika.parse.Parser[Option[String]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="params">(<span name="value">value: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">A parser for an optional literal string that always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>A parser for an optional literal string that always succeeds.</p><p>If the underlying parser succeeds this parser will contain its result as a <code>Some</code>,
if it fails this parser will succeed with a <code>None</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.combinator.Parsers#opt" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt[T](p:laika.parse.Parser[T]):laika.parse.Parser[Option[T]]"></a><a id="opt[T](Parser[T]):Parser[Option[T]]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#opt[T](p:laika.parse.Parser[T]):laika.parse.Parser[Option[T]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.opt.T">T</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="laika.parse.combinator.Parsers.opt.T">T</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">A parser for an optional element that always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>A parser for an optional element that always succeeds.</p><p>If the underlying parser succeeds this parser will contain its result as a <code>Some</code>,
if it fails this parser will succeed with a <code>None</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#prevIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="prevIn(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#prevIn(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevIn</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is one of those specified.
Fails at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#prevIn" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevIn(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="prevIn(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#prevIn(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevIn</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is one of those specified.
Fails at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#prevIs" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="prevIs((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#prevIs(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevIs</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character satisfies the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character satisfies the specified predicate.
Fails at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#prevNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]"></a><a id="prevNot((Char)⇒Boolean):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#prevNot(predicate:Char=&gt;Boolean):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevNot</span><span class="params">(<span name="predicate">predicate: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character does not satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character does not satisfy the specified predicate.
Succeeds at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#prevNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]"></a><a id="prevNot(NonEmptySet[Char]):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#prevNot(chars:cats.data.NonEmptySet[Char]):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is not one of those specified.
Succeeds at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#prevNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prevNot(char:Char,chars:Char*):laika.parse.Parser[Unit]"></a><a id="prevNot(Char,Char*):Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#prevNot(char:Char,chars:Char*):laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prevNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Verifies that the previous character is not one of those specified.</p><div class="fullcomment"><div class="comment cmt"><p>Verifies that the previous character is not one of those specified.
Succeeds at the start of the input and does not consume any input
or produce a result when it succeeds.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#range" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="range(fromChar:Char,toChar:Char):cats.data.NonEmptySet[Char]"></a><a id="range(Char,Char):NonEmptySet[Char]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#range(fromChar:Char,toChar:Char):cats.data.NonEmptySet[Char]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">range</span><span class="params">(<span name="fromChar">fromChar: <span class="extype" name="scala.Char">Char</span></span>, <span name="toChar">toChar: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Creates a NonEmptySet from a Character range.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a NonEmptySet from a Character range.
This set can then be passed to parsers like <code>anyOf</code> or <code>oneOf</code>
which expect a NonEmptySet as a parameter.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#restOfLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restOfLine:laika.parse.Parser[String]"></a><a id="restOfLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#restOfLine:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">restOfLine</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text. Does not include the eol character(s).
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#someNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="someNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]"></a><a id="someNot(NonEmptySet[Char]):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#someNot(chars:cats.data.NonEmptySet[Char]):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someNot</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters that are not one of the specified characters,
fails for empty results.</p>
    </li><li name="laika.parse.text.TextParsers#someNot" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="someNot(char:Char,chars:Char*):laika.parse.text.Characters[String]"></a><a id="someNot(Char,Char*):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#someNot(char:Char,chars:Char*):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someNot</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters that are not one of the specified characters,
fails for empty results.</p>
    </li><li name="laika.parse.text.TextParsers#someOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="someOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixCharacters[String]"></a><a id="someOf(NonEmptySet[Char]):PrefixCharacters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#someOf(chars:cats.data.NonEmptySet[Char]):laika.parse.text.PrefixCharacters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="cats.data.NonEmptySet">NonEmptySet</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="PrefixCharacters.html" class="extype" name="laika.parse.text.PrefixCharacters">PrefixCharacters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters if they match one of the specified characters,
fails if the first character does not match.</p>
    </li><li name="laika.parse.text.TextParsers#someOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="someOf(char:Char,chars:Char*):laika.parse.text.PrefixCharacters[String]"></a><a id="someOf(Char,Char*):PrefixCharacters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#someOf(char:Char,chars:Char*):laika.parse.text.PrefixCharacters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someOf</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>, <span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="PrefixCharacters.html" class="extype" name="laika.parse.text.PrefixCharacters">PrefixCharacters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters if they match one of the specified characters,
fails if the first character does not match.</p>
    </li><li name="laika.parse.text.TextParsers#someWhile" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="someWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]"></a><a id="someWhile((Char)⇒Boolean):Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#someWhile(p:Char=&gt;Boolean):laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">someWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Consumes one or more characters which satisfy the specified predicate,
fails for empty results.</p>
    </li><li name="laika.parse.combinator.Parsers#success" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="success[T](v:T):laika.parse.Parser[T]"></a><a id="success[T](T):Parser[T]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#success[T](v:T):laika.parse.Parser[T]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: <span class="extype" name="laika.parse.combinator.Parsers.success.T">T</span></span>)</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="laika.parse.combinator.Parsers.success.T">T</span>]</span>
      </span>
      
      <p class="shortcomment cmt">A parser that always succeeds with the specified value.</p><div class="fullcomment"><div class="comment cmt"><p>A parser that always succeeds with the specified value.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#textLine" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="textLine:laika.parse.Parser[String]"></a><a id="textLine:Parser[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#textLine:laika.parse.Parser[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">textLine</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses a single text line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single text line from the current input offset (which may not be at the
 start of the line). Fails for blank lines. Does not include the eol character(s).
</p></div></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.text.TextParsers#ws" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ws:laika.parse.text.Characters[String]"></a><a id="ws:Characters[String]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#ws:laika.parse.text.Characters[String]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a href="Characters.html" class="extype" name="laika.parse.text.Characters">Characters</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
Always succeeds, consuming all whitespace found.
</p></div></div>
    </li><li name="laika.parse.text.TextParsers#wsEol" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="wsEol:laika.parse.Parser[Unit]"></a><a id="wsEol:Parser[Unit]"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#wsEol:laika.parse.Parser[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">wsEol</span><span class="result">: <a href="../Parser.html" class="extype" name="laika.parse.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Parses any number of whitespace characters followed
by a newline character.</p>
    </li>
              </ol>
            </div>

        

        <div class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../laika/parse/text/TextParsers.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: ">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
                <span class="name">@Deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.combinator.Parsers">
              <h3>Inherited from <a href="../combinator/Parsers.html" class="extype" name="laika.parse.combinator.Parsers">Parsers</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
